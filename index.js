// index.js ‚Äî KiosKeys Bot (Twilio TwiML + OpenAI extraction + Sheets)
// Dise√±o: pocas idas y vueltas, pide todo en 1 mensaje, resume y confirma.

import express from "express";
import bodyParser from "body-parser";
import twilio from "twilio";
import OpenAI from "openai";
import { google } from "googleapis";

const app = express();
app.use(bodyParser.urlencoded({ extended: false }));
app.use(bodyParser.json());

// ===== Twilio (solo avisos internos) =====
const twilioClient = twilio(process.env.TWILIO_ACCOUNT_SID, process.env.TWILIO_AUTH_TOKEN);

// ===== OpenAI =====
const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

// ===== Google Sheets (opcional) =====
const SHEET_ID  = process.env.GOOGLE_SHEET_ID || "";
const SHEET_TAB = process.env.GOOGLE_SHEET_TAB || "Solicitudes";
let sheets = null;

async function initSheets() {
  if (!SHEET_ID || !process.env.GOOGLE_SERVICE_ACCOUNT_EMAIL || !process.env.GOOGLE_PRIVATE_KEY) return;
  const auth = new google.auth.JWT(
    process.env.GOOGLE_SERVICE_ACCOUNT_EMAIL,
    null,
    (process.env.GOOGLE_PRIVATE_KEY || "").replace(/\\n/g, "\n"),
    ["https://www.googleapis.com/auth/spreadsheets"]
  );
  sheets = google.sheets({ version: "v4", auth });
}
initSheets().catch(console.error);

async function logToSheet(row) {
  if (!sheets || !SHEET_ID) return;
  try {
    await sheets.spreadsheets.values.append({
      spreadsheetId: SHEET_ID,
      range: `${SHEET_TAB}!A1`,
      valueInputOption: "USER_ENTERED",
      requestBody: { values: [row] },
    });
  } catch (e) {
    console.error("Sheets append error:", e.message);
  }
}

// ===== Sesiones (memoria) =====
const sessions = new Map(); // from -> { stage, flow, data, lastReply }

// ===== Utilidades =====
const Y = new Date().getFullYear();
const isYear = v => /^\d{4}$/.test(v) && +v >= 1980 && +v <= Y + 1;
const isCP   = v => /^\d{4}$/.test(v);
const isPat  = v => /^(?:[A-Z]{3}\d{3}|[A-Z]{2}\d{3}[A-Z]{2})$/.test(v);

function clean(text) {
  return (text || "").normalize("NFKC").trim();
}

function normalizePlate(p) {
  return clean(p).toUpperCase().replace(/[^A-Z0-9]/g, "");
}

function toMenu(s) {
  s.stage = "menu";
  s.flow  = null;
  s.data  = {};
  return `¬°Hola! Soy el asistente de *KiosKeys* üëã
Estoy para ayudarte.

Eleg√≠ una opci√≥n:
1) *Solicitud de duplicado*
2) *Cambio de carcasa*
3) *Llave nueva*

Respond√© con *1, 2 o 3*. En cualquier momento escrib√≠ *0* o *menu* para volver aqu√≠.`;
}

function compactSummary(d) {
  const line = (k, v) => (v ? `‚Ä¢ ${k}: ${v}\n` : "");
  return (
    `üìù *Resumen del pedido*\n` +
    line("Rol", d.role) +
    line("Aseguradora", d.aseguradora) +
    line("Marca", d.marca) +
    line("Modelo", d.modelo) +
    line("A√±o", d.anio) +
    line("Patente", d.patente) +
    line("CP", d.cp)
  ).trim();
}

function requiredFields(flow, data) {
  // Lo esencial para coordinar r√°pido con el cerrajero
  const base = ["marca", "modelo", "anio", "patente"];
  if (!data.role) base.unshift("role");
  if (data.role === "ASEGURADO" && !data.aseguradora) base.unshift("aseguradora");
  // CP ayuda a derivaci√≥n (si lo ten√©s en siguiente etapa)
  if (!data.cp) base.push("cp");
  return [...new Set(base)];
}

// ===== Aviso interno silencioso =====
async function alertHumanSafe(clientFrom, summary) {
  const to   = (process.env.HUMAN_WHATSAPP_TO || "").replace(/^whatsapp:/, "");
  const from = process.env.TWILIO_WHATSAPP_FROM;
  if (!to || !from) return;
  const normalizedClient = (clientFrom || "").replace(/^whatsapp:/, "");
  if (to === normalizedClient) return;
  try {
    await twilioClient.messages.create({
      from,
      to: `whatsapp:${to}`,
      body: `üîî Nuevo caso KiosKeys\n${summary}`,
    });
  } catch (e) {
    console.error("Handoff interno fall√≥:", e.message);
  }
}

// ===== Extracci√≥n con IA (pensamiento propio) =====
async function extractWithAI(userText, current) {
  try {
    const system =
`Sos un extractor de datos para un bot de cerrajer√≠a (KiosKeys).
Devolv√©s SIEMPRE JSON v√°lido, sin texto extra.
Campos posibles:
- servicio: "duplicado" | "carcasa" | "llave_nueva" | "consulta" | "humano" | null
- role: "ASEGURADO" | "PARTICULAR" | null
- aseguradora: string|null
- marca: string|null
- modelo: string|null
- anio: string|null (4 d√≠gitos)
- patente: string|null (formato ABC123 o AA123BB)
- cp: string|null (4 d√≠gitos)
- intent_extra: "precio" | "ubicacion" | null

Si el usuario menciona seguro/asegurado, role=ASEGURADO y extra√© aseguradora si est√°.
Pod√©s inferir marca, modelo, a√±o y patente del texto libre aunque vengan mezclados.
No inventes datos. Dej√° null si falta.
`;

    const user = `
Texto del usuario: """${userText}"""
Contexto actual: ${JSON.stringify(current || {})}
Devolv√© JSON:
{"servicio":...,"role":...,"aseguradora":...,"marca":...,"modelo":...,"anio":...,"patente":...,"cp":...,"intent_extra":...}
`;

    const resp = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      temperature: 0.2,
      response_format: { type: "json_object" },
      messages: [
        { role: "system", content: system },
        { role: "user",   content: user   },
      ],
    });

    const content = resp.choices?.[0]?.message?.content || "{}";
    const data = JSON.parse(content);

    // Normalizaciones m√≠nimas
    if (data.anio && !isYear(data.anio)) data.anio = null;
    if (data.cp && !isCP(data.cp)) data.cp = null;
    if (data.patente) {
      data.patente = normalizePlate(data.patente);
      if (!isPat(data.patente)) data.patente = null;
    }

    if (data.role) data.role = data.role.toUpperCase();
    if (data.servicio) {
      const map = { "duplicado":"duplicado", "carcasa":"carcasa", "llave_nueva":"llave", "llave":"llave" };
      data.servicio = map[data.servicio] || data.servicio;
    }

    return data;
  } catch (e) {
    console.error("OpenAI extract error:", e.message);
    return {};
  }
}

// ===== Webhook principal (Twiml) =====
app.post("/whatsapp", async (req, res) => {
  const from = req.body.From;
  const text = clean(req.body.Body);

  let s = sessions.get(from);
  if (!s) {
    s = { stage: "menu", flow: null, data: {}, lastReply: "" };
    sessions.set(from, s);
  }

  let reply;

  // Comandos globales
  if (/^(0|menu|men√∫)$/i.test(text)) {
    reply = toMenu(s);
  } else if (/humano|asesor|persona/i.test(text)) {
    reply = "Un asesor te contactar√° por este chat a la brevedad üôå";
    await alertHumanSafe(from, `Pedido de humano ‚Äî Cliente: ${from.replace("whatsapp:","")}`);
  } else if (/precio|cu[a√°]nto sale|costo|vale/i.test(text)) {
    reply = "üí∞ El precio depende del tipo de llave/servicio. ¬øQuer√©s que un asesor confirme el valor exacto?";
    await alertHumanSafe(from, `Consulta de precios: ‚Äú${text}‚Äù ‚Äî ${from.replace("whatsapp:","")}`);
  } else if (/ubicaci[o√≥]n|d[o√≥]nde est[a√°]n|direcci[o√≥]n|horarios?/i.test(text)) {
    reply = "üìç Av. Hip√≥lito Yrigoyen 114, Mor√≥n. Horario: 9‚Äì13 y 14‚Äì17 hs.";
  }
  else {
    // IA: intentar entender qu√© quiere y extraer datos
    const ai = await extractWithAI(text, s);

    // setear servicio/flow si viene de IA
    if (!s.flow && ai.servicio) {
      if (ai.servicio === "duplicado") s.flow = "duplicado";
      else if (ai.servicio === "carcasa") s.flow = "carcasa";
      else if (ai.servicio === "llave" || ai.servicio === "llave_nueva") s.flow = "llave";
      s.stage = "collect";
    }

    // merge de datos extra√≠dos
    s.data = { ...s.data, ...Object.fromEntries(
      Object.entries(ai).filter(([k]) => ["role","aseguradora","marca","modelo","anio","patente","cp"].includes(k))
    )};

    // si no hay flow a√∫n, usar men√∫
    if (!s.flow) {
      // tambi√©n aceptar 1/2/3
      if (/^1$/.test(text)) { s.flow="duplicado"; s.stage="collect"; }
      else if (/^2$/.test(text)) { s.flow="carcasa";  s.stage="collect"; }
      else if (/^3$/.test(text)) { s.flow="llave";    s.stage="collect"; }
      else {
        reply = toMenu(s);
      }
    }

    // Recolecci√≥n compacta y confirmaci√≥n
    if (!reply && s.flow) {
      const need = requiredFields(s.flow, s.data).filter(f => !s.data[f]);
      if (need.length > 0) {
        // pedir TODO lo faltante en 1 mensaje
        const pretty = need.map(f=>{
          if (f==="role") return "rol (Asegurado/Particular)";
          if (f==="anio") return "a√±o (4 d√≠gitos)";
          if (f==="cp")   return "c√≥digo postal (4 d√≠gitos)";
          return f;
        }).join(", ");

        // ejemplo compacto
        let ejemplo = "La Caja, Ford Fiesta 2018, AB123CD, CP 1708";
        if (!need.includes("aseguradora")) ejemplo = "Ford Fiesta 2018, AB123CD, CP 1708";
        if (s.data.role === "PARTICULAR") ejemplo = "VW Gol 2017, AC123BD, CP 1407";

        reply =
`Perfecto. Para avanzar necesito: *${pretty}*.
Escribilo en *un solo mensaje* (ej: ‚Äú${ejemplo}‚Äù).`;
        s.stage = "collect";
      } else {
        // Tenemos todo ‚Üí pedir confirmaci√≥n en bloque corto
        const summary = compactSummary(s.data);
        reply = `${summary}\n\n¬øConfirm√°s? *1 S√≠* / *2 Corregir*`;
        s.stage = "confirm";
      }
    }

    // Confirmaci√≥n
    if (s.stage === "confirm" && /^1$/.test(text)) {
      // Log a Sheets
      const d = s.data, now = new Date().toLocaleString("es-AR");
      await logToSheet([
        now, from.replace("whatsapp:",""), s.flow,
        d.role || "", d.aseguradora || "", d.marca || "", d.modelo || "", d.anio || "",
        d.patente || "", d.cp || ""
      ]);

      // Aviso interno
      await alertHumanSafe(from, compactSummary(s.data) + `\nServicio: ${s.flow}\nCliente: ${from.replace("whatsapp:","")}`);

      reply = "‚úÖ Perfecto. Ya tom√© el pedido. Un asesor te contactar√° por este chat en breve.";
      // Volver a men√∫ limpio
      reply += `\n\n${toMenu(s)}`;
    } else if (s.stage === "confirm" && /^2$/.test(text)) {
      // Regresar a ‚Äúcollect‚Äù para corregir datos faltantes o err√≥neos
      s.stage = "collect";
      reply = "Sin problema. Indicame las correcciones en *un solo mensaje*.";
    }
  }

  // -------- Anti ‚ÄúOK‚Äù / anti eco + TwiML --------
  const safeReply = (reply || "").trim();
  const isOkOnly = /^ok\.?$/i.test(safeReply);
  const isDuplicate = safeReply && s.lastReply && safeReply === s.lastReply.trim();

  if (!safeReply || isOkOnly || isDuplicate) {
    return res.status(200).end();
  }
  s.lastReply = safeReply;

  const twiml = new twilio.twiml.MessagingResponse();
  twiml.message(safeReply);
  res.type("text/xml").send(twiml.toString());
});

// Healthcheck
app.get("/", (_req, res) => res.send("Bot KiosKeys funcionando üöÄ"));
app.listen(process.env.PORT || 3000, () => {
  console.log("UP on", process.env.PORT || 3000);
});
